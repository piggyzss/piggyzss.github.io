<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  
    <!-- Google Tag Manager -->
    <script>
      ; (function (w, d, s, l, i) {
        w[l] = w[l] || []
        w[l].push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' })
        var f = d.getElementsByTagName(s)[0],
          j = d.createElement(s),
          dl = l != 'dataLayer' ? '&l=' + l : ''
        j.async = true
        j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl
        f.parentNode.insertBefore(j, f)
      })(window, document, 'script', 'dataLayer', 'GTM-WJ7P5KL')
    </script>
    <!-- End Google Tag Manager -->

    <script>
      var _hmt = _hmt || []
        ; (function () {
          var hm = document.createElement('script')
          hm.src = 'https://hm.baidu.com/hm.js?5a0acc897fd96474a2c8f4deac84611a'
          var s = document.getElementsByTagName('script')[0]
          s.parentNode.insertBefore(hm, s)
        })()
    </script>
    <!-- 百度统计 -->

    
      <meta charset="utf-8">
      <meta name="baidu-site-verification" content="vvVgSQUzPU">
      <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
      <meta name="keywords" content>
      
        <meta name="google-site-verification" content="VQowHv5lAVVWJxjKI9bnAWT7NGdOrfS5KnLF07-B7w0">
        
          <meta name="description" content>
          <title>
            Hexo - 
          </title>

          <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
          <link rel="stylesheet" href="/style/style.css">
            <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
            <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
            <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
            <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
            <script>
              hljs.initHighlightingOnLoad();
            </script>
            <script type="text/javascript" src="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"></script>
            <link rel="stylesheet" href="../source/photos/photos.css">
            <script type="text/javascript" src="../source/photos/photo.js"></script>
</head>

<body>
  <div id="fixed-menu">
    <div class="up">
      <svg class="icon" aria-hidden="true">
        <use xlink:href="#icon-fenzu7"/>
      </svg>
    </div>
  </div>
  <div id="progress">
    <div class="line"></div>
  </div>
  <div id="head">
    
      <a href="/" class>
        Home
      </a>
      
      <a href="/archives" class>
        Archives
      </a>
      
      <a href="/about" class>
        About
      </a>
      
      <a href="/music" class>
        music
      </a>
      
      <a href="/gallery" class>
        gallery
      </a>
      
  </div>
  <div id="container">
    <div id="main">
      <div class="navbar">
        <div class="toggle">
          <svg class="icon toggle-icon" aria-hidden="true">
            <use xlink:href="#icon-fenzu3"/>
          </svg>
        </div>
        <div class="search">
          <div class="input-warp">
            <svg class="icon" aria-hidden="true">
              <use xlink:href="#icon-fenzu"/>
            </svg>
            <input type="text" name id="search" placeholder="Search Keys">
          </div>
        </div>
      </div>
      <div class="content">
        <article class="post-entry">
  <div class="header">
    <div class="title">
      ReactHooks(一)
    </div>
    
      <div class="meta">
        <span>
          <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-fenzu4"/>
          </svg>
          2022/04/05
        </span>
        <span>
          <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-fenzu14"/>
          </svg>
          <span>
            
              
                      
          </span>
        </span>
        <span>
          <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-fenzu15"/>
          </svg>
          <span>
            
              
                
                  <a href="/tags/React">
                    React
                  </a>
                  
                    
                      
          </span>
        </span>
        <span class="leancloud-visitors" id="https://piggyzss.github.io/2022/04/05/ReactHooks(一)/" data-flag-title="ReactHooks(一)">
          <svg class="icon" aria-hidden="true">
            <use xlink:href="#icon-fenzu6"/>
          </svg>
          <span class="leancloud-visitors-count"></span>
        </span>
      </div>
      
        
            <div>
            </div>
  </div>
  <h1 id="1、什么是hooks以及为什么是hooks？"><a href="#1、什么是hooks以及为什么是hooks？" class="headerlink" title="1、什么是hooks以及为什么是hooks？"></a>1、什么是hooks以及为什么是hooks？</h1><h3 id="1-1、什么是hooks？"><a href="#1-1、什么是hooks？" class="headerlink" title="1-1、什么是hooks？"></a>1-1、什么是hooks？</h3><blockquote>
<p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
</blockquote>
<p>Hook本身意思是“钩子”，作用就是“勾住某些生命周期函数或某些数据状态，并进行某些关联触发调用”。</p>
<h3 id="1-2、为什么是hooks"><a href="#1-2、为什么是hooks" class="headerlink" title="1-2、为什么是hooks"></a>1-2、为什么是hooks</h3><ul>
<li>缺点一：复杂且不容易理解的“this”</li>
</ul>
<p>例如事件绑定处理函数，都需要bind(this)才可以正确执行；想获取某些自定义属性，都需要使用this.state.xx或this.props.xx。</p>
<ul>
<li>缺点二：组件数据状态逻辑不能重用</li>
</ul>
<p>详细解释如下：</p>
<p>“组件数据状态”是由：定义数据、默认赋值、获取数据、修改数据、数据逻辑几个环节构成。 由于类组件中的组件数据状态state必须写在该组件构造函数内部，无法将state抽离出组件，因此别的组件如果有类似state逻辑，也必须内部自己实现一次，所以才得出“组件数据状态逻辑不能重用”的结论。</p>
<p><strong>通过自定义hook，可以数据状态逻辑从组件中抽离出去（也就是公共可复用的hook），这样同一个hook可以被多个组件使用，解决组件数据状态逻辑并不能重用的问题。</strong></p>
<h3 id="1-3、【注意】"><a href="#1-3、【注意】" class="headerlink" title="1-3、【注意】"></a>1-3、【注意】</h3><p>使用hooks的过程中，以下几点需要注意：</p>
<ul>
<li>Hooks只能运行在函数组件中，不能运行在类组件中</li>
</ul>
<p>准确来说，Hooks只能运行在函数组件的“内部顶层中”，<strong>不能运行在if/for等其他函数的代码体内，不允许被if/for等包裹住。</strong></p>
<ul>
<li>Hooks函数必须为纯函数</li>
</ul>
<p>所谓纯函数就是函数内部不能修改可能影响执行结果的任意参数，确保每次执行的代码结果都是一样的。</p>
<ul>
<li>可以从自定义 Hooks 中调用 Hooks；自定义 Hooks 必须使用 use 开头，这是一种约定。</li>
</ul>
<h1 id="2、useState"><a href="#2、useState" class="headerlink" title="2、useState"></a>2、useState</h1><p>useState的作用是“勾住”函数组件中自定义的变量</p>
<p><code>const [variable,  ``setVariable``] = useState(initialState)</code></p>
<h3 id="2-1、入参"><a href="#2-1、入参" class="headerlink" title="2-1、入参"></a>2-1、入参</h3><p>入参可以是该state的初始值，也可以是一个函数，来通过逻辑计算出默认值</p>
<p>【惰性 initialState】</p>
<p>如果计算的代价比较昂贵，可以传一个函数给 useState，在函数中计算并返回 initialState，此函数只会在初始渲染时被调用一次，后续重新渲染时会被忽略。</p>
<h3 id="2-2、函数式更新"><a href="#2-2、函数式更新" class="headerlink" title="2-2、函数式更新"></a>2-2、函数式更新</h3><p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将回调函数当作参数传递给 setState。该回调函数将接收先前的 state，并返回一个更新后的值。</p>
<ul>
<li><code>setCount(prevData =&gt; prevData+1)</code></li>
</ul>
<p>常用于解决数据异步问题</p>
<p>此处应该有个🌰：偷个懒，回头再补嗷</p>
<h3 id="2-3、更新：替换非合并"><a href="#2-3、更新：替换非合并" class="headerlink" title="2-3、更新：替换非合并"></a>2-3、更新：替换非合并</h3><p>在类组件中，setState是执行的是“异步对比累加赋值”，何为“对比”？ 就是先对比之前数据属性中是否有age，如果有则修改age值，同时不会影响到其他属性的值。</p>
<p>但是，用useState定义的修改函数 setXxxx，执行的是 “异步直接赋值”。</p>
<p>因此若state为对象或数组时，在调用setState时需要拷贝一份，然后修改后进行赋值</p>
<h3 id="2-4、性能问题"><a href="#2-4、性能问题" class="headerlink" title="2-4、性能问题"></a>2-4、性能问题</h3><p>我曾经好奇过一个问题，如果通过setState设置，但是nextValue和preValue完全一样，那么会引发React的rerender吗？</p>
<p>直接上结论：</p>
<ul>
<li>简单类型：如String、Number等，新旧值一样的情况下不会引起重新渲染</li>
</ul>
<!---->

<ul>
<li>复杂类型：即使新旧值 “看上去是一样的” 也会引起重新渲染。除非新旧值指向同一个对象，或者说新旧值是同一个对象的引用时，才不会重新渲染</li>
</ul>
<p>【引申】那么应该使用单个还是多个 state 变量？</p>
<p>官方参考：<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables</a></p>
<h1 id="3、useEffect"><a href="#3、useEffect" class="headerlink" title="3、useEffect"></a>3、useEffect</h1><p>useEffect的作用是“勾住”函数组件中某些生命周期函数。</p>
<p>这些生命周期函数包括：componentDidMount(组件被挂载完成后)、componentDidUpdate(组件重新渲染完成后)、componentWillUnmount(组件即将被卸载前)</p>
<p><code>useEffect(() =&gt; { doSomething }, []])</code></p>
<h3 id="3-1、入参"><a href="#3-1、入参" class="headerlink" title="3-1、入参"></a>3-1、入参</h3><p><strong>【第一个入参】</strong> 函数</p>
<p>它是在第一次挂载完成以及之后更新渲染后会执行的代码块。</p>
<p><strong>这个函数可能会有返回值，倘若有返回值，返回值也必须是一个函数，会在组件被销毁时执行。</strong></p>
<p>例如：</p>
<pre><code class="javascript">useEffect(() =&gt; { 
  //此处为 组件挂载之后和组件重新渲染之后执行的部分
  window.addEventListener(&#39;click&#39;, handleClick)
  return () =&gt; {
    //此处为 组件即将被卸载前执行的部分
    window.addEventListener(&#39;click&#39;, handleClick)
  }
})</code></pre>
<p><strong>【第二个入参】</strong></p>
<ul>
<li>什么都不传，组件每次 render 之后 useEffect 都会调用，相当于 componentDidMount 和 componentDidUpdate</li>
</ul>
<!---->

<ul>
<li>传入一个空数组 []，只会调用一次，相当于 componentDidMount 和 componentWillUnmount</li>
</ul>
<!---->

<ul>
<li>传入一个数组，其中包括各种依赖变量，只有这些变量变动时，useEffect 才会执行</li>
</ul>
<h3 id="3-2、闭包问题"><a href="#3-2、闭包问题" class="headerlink" title="3-2、闭包问题"></a>3-2、闭包问题</h3><p>先看一个栗子：</p>
<pre><code class="javascript">import React, { useState, useEffect } from &#39;react&#39;

const App = () =&gt; {
  const [number, setNumber] = useState(0) //定义变量a，并且默认值为0

  //定义一个useEffect，用于处理累加器
  useEffect(() =&gt; {
    let timer = setInterval(() =&gt; { setNumber(number + 1) }, 1000)
    return () =&gt; {
      clearInterval(timer);
    }
  }, [])

  useEffect(() =&gt; {
    console.log(&#39;update enter&#39;)
  }, [number])

  return &lt;div&gt; {number} &lt;/div&gt;
}

export default App</code></pre>
<p>信心满满的执行一下，发现结果并不符合预期！</p>
<p>问题出在哪儿呢？</p>
<p>打开控制台，会发现有如下报错：<code>React``  Hook useEffect has a missing dependency: &#39;number&#39;. Either include it or remove the dependency array. You can also do a functional update &#39;setNumber(n =&gt; ...)&#39; if you only need &#39;number&#39; in the &#39;setNumber&#39; call</code></p>
<p>这个提示已经告诉我们要怎样修改了，其实就是上一节说到的用于解决异步问题的函数式更新，那么我们咔咔一咔咔操作一番，修改成这样：</p>
<pre><code class="javascript">***
  useEffect(() =&gt; {
    let timer = setInterval(() =&gt; { setNumber(number =&gt; number + 1) }, 1000)
    return () =&gt; {
      clearInterval(timer);
    }
  }, [])
***</code></pre>
<p>run一下，发现没有问题了，完美～</p>
<p>为什么会有这个问题呢？</p>
<p>答：如果useEffect第2个参数为空数组，那么react会为该useEffect的第1个参数建立一个闭包，该闭包里的变量<code>number</code>被永远设定为当初的值，即 0。尽管<code>setInterval</code>正常工作，每次都“正常执行了”，可是 <code>setNumber(number+1)</code>中 <code>number</code>的值一直没变化，一直都是当初的0，所以会出现 0 + 1 一直都等于 1 的结果。</p>
<p>而如果修改成<code>setNumber(number =&gt; number + 1)</code>的形式，那么就解决了数据异步的问题，每次都是读取最新当前<code>number</code>的值。</p>
<p>官方参考：<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often</a></p>
<h1 id="4、useContext"><a href="#4、useContext" class="headerlink" title="4、useContext"></a>4、useContext</h1><p>useContext的作用是“勾住”获取由<code>React.createContext()</code>创建、<code>&lt;XXX.Provider&gt;</code>添加设置的共享数据。</p>
<p>原本不同级别的组件之间传递props必须逐层传递，即便中间层的组件不需要这些数据。数据层层传递增加了组件的复杂性，降低了可复用性。为了解决这个问题，我们可以通过context的方式，在组件顶层或单独的模块中创建一个共享数据对象，这样在任意一个需要共享数据的子组件中去获取即可，避免了数据的层层传递。</p>
<p><code>useContext</code>是<code>&lt;XXX.Consumer&gt;</code>的替代品，可以简化获取共享数据值。</p>
<p>官方栗子：<br>App.js</p>
<pre><code class="javascript">export const GlobalContext = React.createContext()
export default () =&gt; { 
  return (
    &lt;GlobalContext.Provider value={{name:'miaomiao', age:1}}&gt;
        &lt;MiddleComponent /&gt;
    &lt;/GlobalContext.Provider&gt;
  ) 
}</code></pre>
<p>Example.js</p>
<pre><code class="javascript">import { GlobalContext } from &#39;./App&#39;
// 不使用hooks
class Example extends PureComponent { 
  return &lt;GlobalContext.Consumer&gt;
    {
        global =&gt; {
            return &lt;div&gt;{global.name} - {global.age}&lt;/div&gt;
        }
    }
  &lt;/GlobalContext.Consumer&gt;
}

// 使用hooks
export default () =&gt; { 
  const context = useContext(ThemeContext)
  return (
      &lt;div&gt;
        {context.name} - {context.age}
      &lt;/div&gt;
  )
}</code></pre>
<h1 id="5、useMemo"><a href="#5、useMemo" class="headerlink" title="5、useMemo"></a>5、useMemo</h1><p><code>useMemo</code>的作用是“勾住”组件中某些处理函数的返回值，当组件重新渲染时，如果useMemo依赖的数据变量未发生变化，那么直接使用原型链上保存的该函数计算结果，避免在每个渲染上进行昂贵的计算，达到提高组件性能的目的。</p>
<h3 id="5-1、入参"><a href="#5-1、入参" class="headerlink" title="5-1、入参"></a>5-1、入参</h3><p><strong>【第一个入参】</strong> 函数：包含复杂计算且有返回值的函数</p>
<p><strong>【第二个入参】</strong> 依赖项数组</p>
<p>栗子</p>
<pre><code class="javascript">import React, { useState, useMemo } from &#39;react&#39;

const App = () =&gt; {
  const [number, setNumber] = useState(0)
  const [name, setName] = useState(&#39;&#39;)

  const data = useMemo(() =&gt; {
    console.log(&#39;enter&#39;)
    // 实际代码中这里是一系列复杂的运算过程
    return number * number
  }, [number])

  return (
    &lt;&gt;
      &lt;div&gt; {number} {data} &lt;/div&gt;
      &lt;button onClick={() =&gt; setNumber(number + 1)}&gt;add number&lt;/button&gt;
      &lt;div&gt; {name} &lt;/div&gt;
      &lt;button onClick={() =&gt; setName(name + &#39;_temp&#39;)}&gt;change name&lt;/button&gt;
    &lt;/&gt;
  )
}

export default App</code></pre>
<p>可以看到，当name变化的时候，并不会触发data的变化</p>
<h1 id="6、useCallback"><a href="#6、useCallback" class="headerlink" title="6、useCallback"></a>6、useCallback</h1><p>useCallback的作用是“勾住”组件属性中某些处理函数，只有当依赖变量发生改变时才会重新修改并创建新的一份处理函数。</p>
<h3 id="6-1、入参"><a href="#6-1、入参" class="headerlink" title="6-1、入参"></a>6-1、入参</h3><p><strong>【第一个入参】</strong> 函数：内联回调处理函数</p>
<p><strong>【第二个入参】</strong> 依赖项数组</p>
<h3 id="6-2、一些背景小知识"><a href="#6-2、一些背景小知识" class="headerlink" title="6-2、一些背景小知识"></a>6-2、一些背景小知识</h3><h4 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo()"></a>React.memo()</h4><p>我们知道如果父组件reRender，那么该父组件下的所有子组件都会随着父级的reRender而reRender。</p>
<ul>
<li>无论子组件是类组件或是函数组件</li>
</ul>
<!---->

<ul>
<li>无论子组件在本次渲染过程中，子组件是否有任何相关的依赖数据变化</li>
</ul>
<p>假设某父组件中有2个子组件：子组件C1、子组件C2。若因为子组件C1发生了某些操作，引发父组件reRender，这时即便子组件C2没有任何需要更改的地方，也会重新被渲染一次。</p>
<p>对于渲染成本较大的组件，这样的reRender显然不符合预期，react给出的方案是<code>React.PureComponent</code>，<code>React.PureComponent</code>默认会帮我们完成props和state的浅层对比，用以判断是否需要跳过本次reRender。</p>
<p><code>React.PureComponent</code>是针对类组件提出的，函数组件中与之对应的是<code>React.memo()</code>，使用方式如下：</p>
<pre><code class="javascript">import React from &#39;react&#39;
function C2() {
  return &lt;div&gt;xx&lt;/div&gt;;
}
export default React.memo(C2); //使用React.memo包裹住要导出的函数组件</code></pre>
<p>这样组件C2则不会因为父组件reRender而引发不必要的reRender了。</p>
<h3 id="6-3、什么场景下需要使用useCallback"><a href="#6-3、什么场景下需要使用useCallback" class="headerlink" title="6-3、什么场景下需要使用useCallback"></a>6-3、什么场景下需要使用useCallback</h3><p><code>useCallback</code>是通过获取函数在react原型链上的引用，当即将重新渲染时，用旧值的引用去替换旧值，配合<code>React.memo</code>，达到“阻止组件不必要的重新渲染”。</p>
<p>具体来说，就是<code>useCallback</code>可以将组件的某些处理函数挂载到react底层原型链上，并返回该处理函数的引用，当组件每次即将要重新渲染时，确保props中该处理函数为同一函数(因为是同一对象引用，所以===运算结果一定为true)，跳过本次无意义的重新渲染，达到提高组件性能的目的。当然前提是该组件在导出时使用了<code>React.memo()</code>。</p>
<p>栗子：</p>
<p>不使用useCallback</p>
<pre><code class="javascript">Container.jsx
import React, { useState, useCallback } from &#39;react&#39;

import C1 from &#39;./C1&#39;
import C2 from &#39;./C2&#39;

const Container = () =&gt; {
  const [number, setNumber] = useState(0)
  const [name, setName] = useState(&#39;&#39;)

  const handleClick1 = () =&gt; {
    setNumber(number + 1)
  }

  const handleClick2 = () =&gt; {
    setName(name + &#39;_temp&#39;)
  }

  return (
    &lt;&gt;
      &lt;div&gt; {number} {name} &lt;/div&gt;
      &lt;C1 onClick={handleClick1} /&gt;
      &lt;C2 onClick={handleClick2} /&gt;
    &lt;/&gt;
  )
}

export default Container

C1.jsx
import React, { useEffect } from &#39;react&#39;

const C1 = (props) =&gt; {
  const { onClick } = props
  useEffect(() =&gt; {
    console.log(&#39;enter 1&#39;)
  })

  return (
    &lt;div onClick={onClick}&gt;
      app1
    &lt;/div&gt;
  )
}

export default C1

C2.jsx
import React, { useEffect } from &#39;react&#39;

const C2 = (props) =&gt; {
  const { onClick } = props
  useEffect(() =&gt; {
    console.log(&#39;enter 2&#39;)
  })

  return (
    &lt;div onClick={onClick}&gt;
      app2
    &lt;/div&gt;
  )
}

export default C2</code></pre>
<p>我们在点击C1时，触发handleClick1内的执行函数，导致Container组件内部自定义的变量number变化，从而引起Container的reRender；而此时由于handleClick2函数未做任何处理，会导致handleClick2被重新赋值一次（虽然看上去内容一样，但实际上引用已经不一样了），handleClick2的变化又会导致C2组件reRender，从而引起不必要的组件重渲染。</p>
<p>我们利用<code>useCallback</code>改造一下上面的代码：</p>
<pre><code class="javascript">Container.jsx
import React, { useState, useCallback } from &#39;react&#39;

import C1 from &#39;./C1&#39;
import C2 from &#39;./C2&#39;

const Container = () =&gt; {
  const [number, setNumber] = useState(0)
  const [name, setName] = useState(&#39;&#39;)

  const handleClick1 = useCallback(() =&gt; {
    setNumber(number + 1)
  }, [number])

  const handleClick2 = useCallback(() =&gt; {
    setName(name + &#39;_temp&#39;)
  }, [name])

  return (
    &lt;&gt;
      &lt;div&gt; {number} {name} &lt;/div&gt;
      &lt;C1 onClick={handleClick1} /&gt;
      &lt;C2 onClick={handleClick2} /&gt;
    &lt;/&gt;
  )
}

export default Container

C1.jsx
import React, { useEffect } from &#39;react&#39;

const C1 = (props) =&gt; {
  const { onClick } = props
  useEffect(() =&gt; {
    console.log(&#39;enter 1&#39;)
  })

  return (
    &lt;div onClick={onClick}&gt;
      app1
    &lt;/div&gt;
  )
}

export default React.memo(C1)

C2.jsx
import React, { useEffect } from &#39;react&#39;

const C2 = (props) =&gt; {
  const { onClick } = props
  useEffect(() =&gt; {
    console.log(&#39;enter 2&#39;)
  })

  return (
    &lt;div onClick={onClick}&gt;
      app2
    &lt;/div&gt;
  )
}

export default React.memo(C2)</code></pre>
<p>再试一下，发现C1的reRender不会再引起C2的reRender了。</p>
<p>总结：</p>
<ul>
<li>只有父组件同时有多个子组件时，才有必要用useCallback去做性能优化，防止某一个子组件引发的重新渲染也导致其他子组件跟着重新渲染</li>
</ul>
<!---->

<ul>
<li>useCallback可以保证，只要在依赖项数组不变的情况下，无论 render 多少次，函数都是同一个函数，从而减少开销</li>
</ul>
<h3 id="6-4、useCallback的滥用"><a href="#6-4、useCallback的滥用" class="headerlink" title="6-4、useCallback的滥用"></a>6-4、useCallback的滥用</h3><p>为什么滥用useCallback有时候会适得其反？</p>
<p>单从组件上看，内联函数是一定会创建的（上面的callback内联函数），而无意义的创建和内部每次的浅比较都是会消耗一定性能的。</p>
<p>因此useCallback的使用一定要分清使用场景才能达到效果。</p>


    

        <!-- Comments -->
        <div class="comments" id="zss">
          
            <br><br>
            
              <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script>
        var disqus_shortname = 'shanshan';
        var disqus_config = function () {
            this.page.url = 'https://piggyzss.github.io/2022/04/05/ReactHooks(一)/';
            this.page.identifier = '/2022/04/05/ReactHooks(一)/';
        };
        (function() {
            var d = document, s = d.createElement('script');
            s.type = 'text/javascript';
            s.src = '//'+disqus_shortname+'.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow noopener">comments powered by Disqus.</a></noscript>
</div>

    <div id="gitment_title" class="gitment_title"></div>
    <div id="container" style="display:none"></div>
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script>
      const myTheme = {
        render(state, instance) {
          const container = document.createElement('div');
          container.lang = "en-US";
          container.className = 'gitment-container gitment-root-container';
          container.appendChild(instance.renderHeader(state, instance));
          container.appendChild(instance.renderEditor(state, instance));
          container.appendChild(instance.renderComments(state, instance));
          container.appendChild(instance.renderFooter(state, instance));
          return container;
        }
      }
      function showGitment() {
        $("#gitment_title").attr("style", "display:none");
        $("#zss").attr("style", "").addClass("gitment_container");
        var gitment = new Gitment({
          id: decodeURI(window.location.pathname),
          theme: myTheme,
          owner: 'piggyzss',
          repo: 'piggyzss.github.io/',
          oauth: {
            client_id: '09a2760e2209a8728279',
            client_secret: '1162d7e456f9c8d3f15f164e63f5d253679445a5'
          }
        });
        gitment.render('zss');
      }
      showGitment();
    </script>

                
        </div>

        <!--<div id="comment"></div>-->

</article>
      </div>
      <footer>
        <div class="copyright">
          ©2019 <a href="https://piggyzss.github.io">
            Powered by shanshan
        </a></div>
        
      </footer>
    </div>
    <div id="card-wrap">
      <div class="card">
        <div class="logo-widget">
          <div class="author">
            SecretGarden
          </div>
          <!--<div class="logo" style="background-image: url('/images/logo.jpeg')"></div>-->
        </div>
        <div class="locate-widget">
          <div class="city-wrap">
            <svg class="icon location" aria-hidden="true">
              <use xlink:href="#icon-fenzu9"/>
            </svg>
            <span id="city-name"></span>
          </div>
          <div class="weather-wrap">
            <div id="weather-img">
              <svg class="icon weather" aria-hidden="true">
                <use xlink:href="#icon-qingjiafeng"/>
              </svg>
            </div>
            <div id="weather-detail"></div>
          </div>
        </div>
        <div class="follow-widget">
          
            <a href="https://github.com/piggyzss" target="_block">
              <svg class="icon font" aria-hidden="true">
                <use xlink:href="#icon-github"/>
              </svg>
            </a>
            
            <a href="https://www.instagram.com/doudou_lucky7/" target="_block">
              <svg class="icon font" aria-hidden="true">
                <use xlink:href="#icon-instagram"/>
              </svg>
            </a>
            
            <a href target="_block">
              <svg class="icon font" aria-hidden="true">
                <use xlink:href="#icon-weibo"/>
              </svg>
            </a>
            
              
                <a href="/atom.xml" target="_block">
                  <svg class="icon font" aria-hidden="true">
                    <use xlink:href="#icon-rss"/>
                  </svg>
                </a>
                
        </div>
        
          
            <div class="toc-widget">
              <div class="title">
                <span>Toc</span>
              </div>
              <div class="post-toc">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1、什么是hooks以及为什么是hooks？"><span class="toc-text">1、什么是hooks以及为什么是hooks？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1、什么是hooks？"><span class="toc-text">1-1、什么是hooks？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2、为什么是hooks"><span class="toc-text">1-2、为什么是hooks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3、【注意】"><span class="toc-text">1-3、【注意】</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#2、useState"><span class="toc-text">2、useState</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、入参"><span class="toc-text">2-1、入参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、函数式更新"><span class="toc-text">2-2、函数式更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3、更新：替换非合并"><span class="toc-text">2-3、更新：替换非合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4、性能问题"><span class="toc-text">2-4、性能问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、useEffect"><span class="toc-text">3、useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1、入参"><span class="toc-text">3-1、入参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2、闭包问题"><span class="toc-text">3-2、闭包问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4、useContext"><span class="toc-text">4、useContext</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5、useMemo"><span class="toc-text">5、useMemo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1、入参"><span class="toc-text">5-1、入参</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6、useCallback"><span class="toc-text">6、useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1、入参"><span class="toc-text">6-1、入参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2、一些背景小知识"><span class="toc-text">6-2、一些背景小知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React-memo"><span class="toc-text">React.memo()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3、什么场景下需要使用useCallback"><span class="toc-text">6-3、什么场景下需要使用useCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4、useCallback的滥用"><span class="toc-text">6-4、useCallback的滥用</span></a></li></ol></li>
              </div>
            </div>
            
              
                <div class="category-widget">
                  <div class="title">
                    <span>Categories</span>
                    <span><a href="/archives">···</a></span>
                  </div>
                  <div class="list">
                    <ul>
                      
                        
                          <li>
                            <a href="/categories/code/">
                              code
                            </a>
                          </li>
                          
                            
                    </ul>
                  </div>
                </div>
                <div class="tag-widget">
                  <div class="title">
                    <span>Tag Cloud</span>
                    <span><a href>···</a></span>
                  </div>
                  <div class="tag-cloud">
                    <a href="/tags/React/" style="font-size: 16.5px; color: #4a4a4a">React</a> <a href="/tags/前端/" style="font-size: 20px; color: #4a4a4a">前端</a> <a href="/tags/设计模式/" style="font-size: 13px; color: #4a4a4a">设计模式</a>
                  </div>
                </div>
      </div>
    </div>
  </div>
</body>

  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WJ7P5KL" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  

</html>
<script type="text/javascript">
  window.THEME_CONFIG = JSON.parse('{"title":"Hexo","subtitle":null,"description":null,"author":"shanshan","language":"en","timezone":null,"url":"https://piggyzss.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":true,"relative_link":false,"future":true,"highlight":{"enable":false,"auto_detect":false,"line_number":true,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"hexo-theme-huhu","deploy":{"type":"git","repository":"https://github.com/piggyzss/piggyzss.github.io.git","branch":"master"},"ignore":[],"keywords":null,"highlight_theme":"normal","index_generator":{"per_page":10,"order_by":"-date","path":""},"gitment":{"enable":true,"mint":true,"count":true,"lazy":false,"cleanly":false,"language":null,"github_user":"piggyzss","github_repo":"piggyzss.github.io/","client_id":"09a2760e2209a8728279","client_secret":"1162d7e456f9c8d3f15f164e63f5d253679445a5","proxy_gateway":null,"redirect_protocol":null},"category_generator":{"per_page":10},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true,"sanitizeUrl":false,"headerIds":true},"server":{"port":4000,"log":false,"compress":false,"header":true},"menu":{"home":"/","archives":"/archives","about":"/about","music":"/music","gallery":"/gallery"},"logo":"/images/logo.png","categories_max":5,"tags_max":10,"favicon":"/images/favicon.ico","site_search":true,"rss":"/atom.xml","follow":{"github":"https://github.com/piggyzss","instagram":"https://www.instagram.com/doudou_lucky7/","weibo":""},"search_url":"/search.xml","site_icp":"","site_friends":{"房间里的小猫咪":"http://baidu.com"},"changyan":{"appid":"","conf":""},"valine":{"API_ID":"FjXColpwTL0BsrjJIN8Pmnn0-gzGzoHsz","API_KEY":"Ar7tucPRn3KV7UOidQxESoys"},"share":["weibo","weixin","qqkongjian","QQ","douban","facebook","twitter","google"],"cdn_module":{"av_min":"https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min","jquery":"https://cdn.bootcss.com/jquery/3.4.1/jquery.min","busuanzi":"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini","confirm":"https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min","fancybox":"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min"},"google_site_verification":"VQowHv5lAVVWJxjKI9bnAWT7NGdOrfS5KnLF07-B7w0","gtm_id":"GTM-WJ7P5KL","baidu_push":true,"reward":{"weixin":"images/weixin.png","zhifubao":"images/zhifubao.png"},"disqus":{"shortname":"shanshan"},"post":{"date_format":"dddd, MMMM Do YYYY, h:mm a","comments":{"enable":true,"type":"disqus"}}}')
  window.loadJs = function (d, m, a) {
    var c = document.getElementsByTagName('head')[0] || document.head || document.documentElement
    var b = document.createElement('script')
    b.defer = true
    b.setAttribute('type', 'text/javascript')
    b.setAttribute('charset', 'UTF-8')
    b.setAttribute('async', 'true')
    b.setAttribute('src', d)
    m && b.setAttribute('data-main', '/scripts/app')
    if (typeof a === 'function') {
      if (window.attachEvent) {
        b.onreadystatechange = function () {
          var e = b.readyState
          if (e === 'loaded' || e === 'complete') {
            b.onreadystatechange = null
            a()
          }
        }
      } else {
        b.onload = a
      }
    }
    c.appendChild(b)
  }
  loadJs('https://cdn.bootcss.com/require.js/2.3.6/require.min.js', true, function () {
    require.config({
      paths: {
        // site
        share: 'share',
        iconfont: 'iconfont',
        hodgepodge: 'hodgepodge',
        valine: ['cdn/Valine.min'],

        // cdn
        av: ['https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min', 'cdn/av-min'],
        jquery: ['https://cdn.bootcss.com/jquery/3.4.1/jquery.min', 'cdn/jquery.min'],
        busuanzi: ['//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini', 'cdn/busuanzi.pure.mini'],
        confirm: ['https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min', 'cdn/jquery.confirm.min'],
        fancybox: ['https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min', 'cdn/jquery.fancybox.min']
      },

      map: {
        '*': {
          // css: '/scripts/cdn/css-min.js'
          css: 'https://cdn.bootcss.com/require-css/0.1.10/css.min.js'
        }
      },

      shim: {
        fancybox: {
          // deps: ['css!../style/fancybox']
          deps: ['css!https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css']
        },
        confirm: {
          // deps: ['css!../style/confirm']
          deps: ['css!https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min.css']
        }
      },

      // 加载超时
      waitSeconds: 3
    })
  })
</script>

  <script>
      ; (function () {
        var bp = document.createElement('script')
        var curProtocol = window.location.protocol.split(':')[0]
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js'
        }
        var s = document.getElementsByTagName('script')[0]
        s.parentNode.insertBefore(bp, s)
      })()
  </script>
  